---
id: stationary_objects
title: 静止对象检测
---

## 什么是静止对象？

当被追踪的对象在连续多帧中保持几乎相同的位置时，Frigate会将其判定为静止对象。这个判定阈值可在配置文件的`detect -> stationary -> threshold`中设置，默认值为帧率的10倍（即10秒）。一旦对象被判定为静止，除非检测到其内部发生运动或位置变化，否则将保持静止状态。

## 静止对象检测的意义

对象被判定为静止后，Frigate将不再持续对其运行对象检测。这能有效降低资源消耗，避免对无运动变化的对象进行冗余检测。同时使系统具备上下文感知能力，例如可以[选择性保留录像片段](record.md#不同保留模式的含义)，仅记录对象处于活动状态的时段。

需要注意的是，单纯的光线变化（如停放的车辆受光照变化）不会使静止对象重新变为活动状态。

## 参数调优

默认配置如下：

```yaml
detect:
  stationary:
    interval: 50  # 检测间隔帧数
    threshold: 50 # 静止判定阈值
```

- `interval`：设置对静止对象运行检测的频率。默认每50帧检测一次，确保对象仍然存在
- `threshold`：对象需要保持静止的连续帧数才能被判定为静止

注意：无法通过调整`interval`完全禁用静止对象追踪。

## 技术实现原理

Frigate并非从一开始就支持静止对象追踪功能。让我们通过一个实际案例说明其必要性：

假设需要记录所有进入车道的车辆：
1. 简单方案：仅在车道区域检测到运动时运行对象检测
   - 但无法确定车辆的行驶轨迹（左转/右转进入）
   - 无法关联之前在路边停留的车辆
   - 当车道附近有人修剪草坪时，难以区分车辆和园丁的运动

2. 进阶方案：通过对象追踪赋予唯一ID
   - 需要解决多目标交叉时的ID分配问题
   - 当被追踪车辆接近路边停放的车辆时：
     - 车灯反射会导致误检测出多个车辆
     - 原有单一检测框突然变成多个检测框
     - 传统算法（如卡尔曼滤波）在这种情况下错误率较高

3. 静止对象追踪的优势：
   - 预先标记路边停放车辆为静止对象
   - 新出现的车辆会被识别为独立目标
   - 大幅降低ID分配错误率（虽然仍不完美）

当前系统最大的挑战是处理对象完全遮挡的情况（如一辆车完全挡住另一辆车）。这是未来版本需要改进的方向。